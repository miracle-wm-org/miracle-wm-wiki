{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"miracle-wm","text":"<p>miracle-wm is a Wayland compositor based on Mir. It features a tiling window manager at its core, very much in the style of i3 and sway. The intention is to build a compositor that is flashier and more feature-rich than either of those compositors, like swayfx.</p> <p>See the installation guide for installation instructions on your platform.</p> <p>Note</p> <p>If none of this makes any sense to you or you're new to Wayland or Linux, check out the What is a Wayland compositor? document for a structured walk through the entire ecosystem.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>A tiling window manager, similar to <code>i3</code> and <code>sway</code><ul> <li>Built-in support for inner/outer gaps</li> </ul> </li> <li>An optional floating window manager for individual windows</li> <li>A YAML configuration file</li> <li>Support for the following wayland protocols:<ul> <li>ext_session_lock_manager_v1</li> <li>mir_shell_v1</li> <li>wl_shell</li> <li>xdg_wm_base</li> <li>zwlr_foreign_toplevel_manager_v1</li> <li>zwlr_layer_shell_v1</li> <li>zwlr_screencopy_manager_v1</li> <li>zwlr_virtual_pointer_manager_v1</li> <li>zwp_input_method_manager_v2</li> <li>zwp_text_input_manager_v1</li> <li>zwp_text_input_manager_v2</li> <li>zwp_text_input_manager_v3</li> <li>zwp_virtual_keyboard_manager_v1</li> <li>zxdg_output_manager_v1</li> <li>zxdg_shell_v6</li> <li>zwp_idle_inhibit_manager_v1</li> <li>zwp_input_method_v1</li> <li>zwp_input_panel_v1</li> <li>zwp_pointer_constraints_v1</li> <li>zwp_primary_selection_device_manager_v1</li> <li>zwp_relative_pointer_manager_v1</li> </ul> </li> <li>Support for a wide array of graphics cards, including hybrid systems and outputs driven by Nvidia's proprietary drivers</li> <li>Workspace support</li> <li>Growing support for <code>i3</code>/<code>sway</code> IPC<ul> <li>A minimal implementation for <code>waybar</code> at the moment</li> </ul> </li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Github Repository</li> <li>Snapcraft.io listing</li> <li>Mir, the library that <code>miracle-wm</code> uses for all of the heavy-lifting</li> <li>Miriway, another compositor built on top of Mir</li> </ul>"},{"location":"ipc/","title":"IPC Support","text":"<p>Miracle implements i3's ipc support. In the future, miracle will extend this communication channel for its own purposes.</p>"},{"location":"ipc/#i3-ipc-support","title":"i3 IPC Support","text":"<p>The following provides the list of requests that are fully supported:</p> <ul> <li>\u2705 <code>RUN_COMMAND</code></li> <li>\u2705 <code>GET_WORKSPACES</code></li> <li>\ud83d\udd28 <code>SUBSCRIBE</code></li> <li>\u2705 <code>GET_OUTPUTS</code></li> <li>\ud83d\udd28 <code>GET_TREE</code></li> <li>\u274c <code>GET_BAR_CONFIG</code></li> <li>\u2705 <code>GET_VERSION</code></li> <li>\u2705 <code>GET_BINDING_NODES</code></li> <li>\u274c <code>GET_CONFIG</code></li> <li>\u274c <code>SEND_TICK</code></li> <li>\u274c <code>SYNC</code></li> <li>\u2705 <code>GET_BINDING_STATE</code></li> </ul>"},{"location":"ipc/#run_command-support","title":"<code>RUN_COMMAND</code> Support","text":"<p>i3 supports a list of commands.</p> <p>The following provides a list of criteria queries that are supported:</p> <ul> <li>\u2705 <code>all</code></li> <li>\u274c <code>class</code></li> <li>\u274c <code>instance</code></li> <li>\u274c <code>window_role</code></li> <li>\u274c <code>window_type</code></li> <li>\u274c <code>machine</code></li> <li>\u274c <code>id</code></li> <li>\u2705 <code>title</code></li> <li>\u274c <code>urgent</code></li> <li>\u274c <code>workspace</code></li> <li>\u274c <code>con_mark</code></li> <li>\u274c <code>con_id</code></li> <li>\u274c <code>floating</code></li> <li>\u274c <code>floating_from</code></li> <li>\u274c <code>tiling</code></li> <li>\u274c <code>tiling_from</code></li> </ul> <p>The following provides a list of commands that are supported:</p> <ul> <li>\u2705 <code>exec</code></li> <li>\u2705 <code>split</code></li> <li>\u274c <code>layout</code></li> <li>\u2705 <code>focus</code></li> <li>\u2705 <code>move</code></li> <li>\u274c <code>swap</code></li> <li>\u2705 <code>sticky</code></li> <li>\u274c <code>workspace</code></li> <li>\u274c <code>move</code> containers or windows to a different screen</li> <li>\u274c <code>move</code> containers or windows to a mark</li> <li>\u274c <code>resize</code></li> <li>\u274c <code>mark</code></li> <li>\u274c <code>unmark</code></li> <li>\u274c <code>title_format</code></li> <li>\u274c <code>title_window_icon</code></li> <li>\u274c <code>border</code></li> <li>\u274c <code>shmlog</code></li> <li>\u274c <code>debuglog</code></li> <li>\u274c <code>restart</code></li> <li>\u274c <code>reload</code></li> <li>\u274c <code>exit</code></li> <li>\u274c <code>scratchpad</code></li> <li>\u274c <code>nop</code></li> <li>\u274c <code>bar</code></li> <li>\u274c <code>gaps</code></li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The goal is to have an environment that I am comfortable daily-driving by July 2024. This goal will be marked by the <code>1.0.0</code> release. Until then, all releases will be <code>0.x.0</code>.</p> <p>The dates attached to these releases aren't set in stone. Any release may come earlier if the work is done. Also, new features may be added to the release while it's in progress if priority changes, which may push back the release date.</p>"},{"location":"roadmap/#010","title":"\u2705 0.1.0","text":"<p>Proof of Concept (Due: February 17th)</p> <p>Features:</p> <ul> <li> Window management<ul> <li> Layout of new windows</li> <li> Delete window</li> <li> Resizing windows</li> <li> Gaps in windows</li> <li> Account for minimum sizes on windows (e.g. gedit)</li> <li> Handle exclusion zones</li> <li> Handle fullscreen windows</li> </ul> </li> <li> Navigation<ul> <li> Changing selected window with keyboard</li> <li> Moving window with keyboard shortcuts</li> </ul> </li> <li> Outputs<ul> <li> Output creation</li> <li> Output updating</li> <li> output deletion</li> </ul> </li> <li> Application quit command</li> <li> Workspaces<ul> <li> Workspace switching</li> <li> Moving windows between workspaces</li> </ul> </li> <li> Configuration<ul> <li> Gap size</li> <li> Action key</li> <li> Startup apps</li> <li> Startup apps</li> <li> Override default keybindings</li> <li> Custom keybindings</li> </ul> </li> </ul>"},{"location":"roadmap/#020","title":"\u2705 0.2.0","text":"<p>Stabilization + Usability (Due: April 15th)</p> <p>Features:</p> <ul> <li> Major bugs + performance<ul> <li> No crashes after a week of daily-driving</li> </ul> </li> <li> Configuration<ul> <li> Hot reloading</li> <li> Resize jump</li> <li> Outer gaps</li> </ul> </li> <li> Floating windows<ul> <li> Floating window support (pop out of/into tiles, resizing, moving)</li> <li> \"Pin to workspace\" mode</li> </ul> </li> <li> I3 IPC support for workspaces</li> <li> Packaging<ul> <li> Deb (jammy, mantic, noble, multi-architecture)</li> <li> Fedora</li> </ul> </li> </ul>"},{"location":"roadmap/#030","title":"\ud83d\udea7 0.3.0","text":"<p>Aimations + Sway IPC Release (Due: June 15th)</p> <p>This release relies on having the Mir's renderer capabilities opened up to us. If we can override the renderer, we can put whatever we like on the screen.</p> <p>Features:</p> <ul> <li> Highlight border around selected window (carry over from 0.2.0)</li> <li> Animation (requires access to Mir renderer)<ul> <li> Window movement interpolation</li> <li> Window size interpolation</li> <li> Workspace change</li> <li> Move window to workspace</li> <li> Opening</li> <li> Configuration support</li> </ul> </li> </ul>"},{"location":"roadmap/#040","title":"0.4.0","text":"<p>Pointer Support + Animation + More I3 IPC (Due July 31st)</p> <p>Features:</p> <ul> <li> Stacking windows</li> <li> Pointer support for tiling actions<ul> <li> Drag tiles around</li> <li> Resize tiles with pointer</li> </ul> </li> <li> Animation<ul> <li> Closing windows</li> </ul> </li> <li> Configuration<ul> <li> Display configuration (depends on https://github.com/mattkae/miracle-wm/issues/93)</li> </ul> </li> <li> Full I3 IPC integration</li> <li> Multi monitor support<ul> <li> Zero monitors</li> </ul> </li> </ul>"},{"location":"roadmap/#100","title":"1.0.0","text":"<p>Official Release (Due October 15th)</p> <p>Features:</p> <ul> <li> Bug free</li> <li> Tons of test coverage</li> <li> IDEA: Workspace/window overview view (similar to GNOME)</li> <li> IDEA: Settings app</li> <li> IDEA: Context menu on window with support for actions</li> <li> IDEA: Focus mode, where the focused application appears up front and center</li> <li> IDEA: A minimal default shell, including a panel, launcher, background, etc.</li> <li> IDEA: \"Freestyle tiling\": This would mean that tiling can extend beyond the screen and that the screen can be navigated via scrolling, panning, or anchor points. Workspaces would still be available in this mode, although they would be less relevant.</li> <li> IDEA: Workspaces could be unified in one mega scrolling view to give the illusion of one continuous workspace with \"sections\"</li> </ul>"},{"location":"screenshare/","title":"Screen Sharing","text":"<p>Screensharing in Wayland is done with the help of Portals. Portals were initially designed to allow applications sandboxes via Flatpak to access resources of the desktop, but have since gained popularity outside of the realm of Flatpaks. In our case, we can use the screen sharing portal to allow applications to access the contents of the Wayland compositor.</p> <p>Note</p> <p>Please be aware that you will only be able to share a single screen with this method, not individual windows.</p>"},{"location":"screenshare/#setup","title":"Setup","text":""},{"location":"screenshare/#installation","title":"Installation","text":"<p>First, we need to install xdg-desktop-portal-wlr. Unfortunately, Mir only has support for v0.5.0 of this software, so we will need to checkout the source at a particualr commit:</p> <pre><code>git clone https://github.com/emersion/xdg-desktop-portal-wlr\ncd xdg-desktop-portal-wlr\ngit checkout 7c0f352  # This is release 0.5.0\n</code></pre> <p>Next, we can build the project: <pre><code>meson setup builddir\ncd builddir\nninja -j4\nsudo ninja install\n</code></pre></p>"},{"location":"screenshare/#configuration","title":"Configuration","text":"<p>First, let's add a new environment variable to our Mir configuration: <pre><code># ~/.config/miracle-wm.yaml\n\nenvironment_variables:\n  - key: XDG_CURRENT_DESKTOP\n    value: mir\n</code></pre></p> <p>Next, create a file at <code>~/.config/xdg-desktop-portal/mir-portals.conf</code> and write: <pre><code># ~/.config/xdg-desktop-portal/mir-portals.conf\n\n[preferred]\ndefault=gtk\norg.freedesktop.impl.portal.Screenshot=wlr\norg.freedesktop.impl.portal.ScreenCast=wlr\n</code></pre></p> <p>Next, create a file at <code>~/.config/xdg-desktop-portal-wlr/config</code> and write:</p> <pre><code># ~/.config/xdg-desktop-portal-wlr/config\n\n[screencast]\noutput_name=HDMI-A-1\nmax_fps=30\n#exec_before=disable_notifications.sh\n#exec_after=enable_notifications.sh\nchooser_type=simple\nchooser_cmd=slurp -f %o -or\n</code></pre> <p>Finally modify <code>/usr/share/xdg-desktop-portal/portals/wlr.portal</code> to include \"Mir\" in the \"UseIn\" value:</p> <pre><code># /usr/share/xdg-desktop-portal/portals/wlr.portal\n\n[portal]\nDBusName=org.freedesktop.impl.portal.desktop.wlr\nInterfaces=org.freedesktop.impl.portal.Screenshot;org.freedesktop.impl.portal.ScreenCast;\nUseIn=wlroots;sway;Wayfire;river;phosh;Hyprland;Mir;\n</code></pre>"},{"location":"screenshare/#running","title":"Running","text":"<p>First, create a script somewhere called <code>run_xdg_desktop_portal_wlr.sh</code> with the following contents:</p> <pre><code># /usr/local/bin/run_xdg_desktop_portal_wlr.sh\n\n# Export WAYLAND_DISPLAY and XDG_CURRENT_DESKTOP to dbus\ndbus-update-activation-environment --systemd WAYLAND_DISPLAY XDG_CURRENT_DESKTOP=mir\n\n# Stop xdg-desktop-portal\nsystemctl --user stop xdg-desktop-portal\n\n# Also, you may want do stop any other portal service that you have enabled, e.g.:\nsystemctl --user stop xdg-desktop-portal-gtk\n\n# Start xdg-desktop-portal-*\nsystemctl --user start xdg-desktop-portal\nsystemctl --user start xdg-desktop-portal-wlr\n</code></pre> <p>In your <code>miracle-wm.yaml</code> configuration file, add:</p> <pre><code># ~/.confg/miracle-wm.yaml\n\nstartup_apps:\n  - command: run_xdg_desktop_portal_wlr.sh\n</code></pre> <p>Restart your compositor and then open up <code>obs-studio</code> or <code>Google Meet</code> and see that you are able to share your screen.</p>"},{"location":"configuration/action_key/","title":"Action Key","text":"<p>The action key defines the primary key that will initiate a command in the compositor. Default Keybinds and Custom Actions can refer to this key using the word <code>primary</code> as a modifier key. Please see those configuration options for more info.</p>"},{"location":"configuration/action_key/#key","title":"Key","text":"<pre><code>action_key\n</code></pre>"},{"location":"configuration/action_key/#value","title":"Value","text":"<p>A <code>Modifier</code> string, which is defined as a name in the following table:</p> Name Description <code>alt</code> Any alt key <code>alt_left</code> The left alt key only <code>alt_right</code> The right alt key only <code>shift</code> Any shift key <code>shift_left</code> The left shift key only <code>shift_right</code> The right shift key only <code>ctrl</code> Any ctrl key <code>ctrl_left</code> The left ctrl key only <code>ctrl_right</code> The right ctrl key only <code>meta</code> The <code>super</code> or <code>windows</code> key <code>meta_left</code> The left <code>super</code> or <code>windows</code> key only <code>meta_right</code> The right <code>super</code> or <code>windows</code> key only <code>sym</code> The sym key <code>function</code> The <code>fn</code> key <code>caps_lock</code> The caps lock key <code>num_lock</code> The num lock key <code>scroll_lock</code> The scroll lock key"},{"location":"configuration/action_key/#default","title":"Default","text":"<pre><code>meta\n</code></pre> <p>This is the <code>super</code> or <code>windows</code> key.</p>"},{"location":"configuration/action_key/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\naction_key: shift\n</code></pre>"},{"location":"configuration/animations/","title":"Animations","text":"<p>Miracle supports a number of different built-in animations that can be configured by the user. If you would like to turn off animations by default, please see Enable Animations.</p>"},{"location":"configuration/animations/#key","title":"Key","text":"<pre><code>animations\n</code></pre>"},{"location":"configuration/animations/#value","title":"Value","text":"<p>A list of: <pre><code># The event that you want to animate\nevent: window_open,\n    window_move,\n    window_close,\n    workspace_switch\n\n# The type of animation that will happen when the event is triggered\ntype: disabled,\n    slide,\n    grow,\n    shrink,\n\n# The interpolation function applied to the animation.\n# https://easings.net/ is a great resource to describe these\nfunction: linear,\n    ease_in_sine,\n    ease_out_sine,\n    ease_in_out_sine,\n    ease_in_quad,\n    ease_out_quad,\n    ease_in_out_quad,\n    ease_in_cubic,\n    ease_out_cubic,\n    ease_in_out_cubic,\n    ease_in_quart,\n    ease_out_quart,\n    ease_in_out_quart,\n    ease_in_quint,\n    ease_out_quint,\n    ease_in_out_quint,\n    ease_in_expo,\n    ease_out_expo,\n    ease_in_out_expo,\n    ease_in_circ,\n    ease_out_circ,\n    ease_in_out_circ,\n    ease_in_back,\n    ease_out_back,\n    ease_in_out_back,\n    ease_in_elastic,\n    ease_out_elastic,\n    ease_in_out_elastic,\n    ease_in_bounce,\n    ease_out_bounce,\n    ease_in_out_bounce\n\n# Time in seconds that the animation will take to complete\nduration: float\n\n# Constant values that you can tweak for the various easing\n# functions. You can find their meanings on https://easings.net/\nc1: float  # default: 1.2\nc2: float  # default: 1.83\nc3: float  # default: 2.2\nc4: float  # default: 2.0943951023931953\nc5: float  # default: 1.3962634015954636\nn1: float  # default: 7.5625\nd1: float  # default: 2.75\n</code></pre></p>"},{"location":"configuration/animations/#default","title":"Default","text":"<pre><code>animations:\n    - event: window_open\n      type: grow\n      function: ease_in_out_back\n      duration: 0.25\n    - event: window_move\n      type: slide\n      function: ease_in_out_back\n      duration: 0.25\n    - event: window_close\n      type: shrink\n      function: ease_out_back\n      duration: 0.25\n    - event: workspace_switch\n      type: slide\n      function: ease_out_sine\n      duration: 0.175\n</code></pre>"},{"location":"configuration/animations/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\n# Override the workspace switching animations such that it takes\n# 1s and linearally interpolates to the target workspace\nanimations:\n  - event: workspace_switch\n    type: slide\n    duration: 1\n    function: linear\n</code></pre>"},{"location":"configuration/border/","title":"Border","text":"<p>Specify a border for non-focused and focused tiles.</p>"},{"location":"configuration/border/#key","title":"Key","text":"<pre><code>border\n</code></pre>"},{"location":"configuration/border/#value","title":"Value","text":"<pre><code>border:\n  size: int  # Size in pixels\n  color: Color # Hex color (rgba) or rgba YAML object\n  focus_color: Color # Hex color (rgba) or rgba YAML object\n</code></pre>"},{"location":"configuration/border/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nborder:\n  size: 2\n  color: 0xffff0000\n  focus_color:\n    r: 0\n    g: 255\n    b: 0\n    a: 255\n</code></pre>"},{"location":"configuration/custom_actions/","title":"Custom Actions","text":"<p>The user may define a list of custom actions, which are shell commands bound to a specific key combination. These actions always have preference over those defined in Default Keybinds when they are bound to the same key combination.</p>"},{"location":"configuration/custom_actions/#key","title":"Key","text":"<pre><code>custom_actions\n</code></pre>"},{"location":"configuration/custom_actions/#value","title":"Value","text":"<p>A list of: </p> <pre><code># The shell command that you want to execute\n- command: string\n\n# The key action that will trigger the default action\n - action: \"up\" | \"down\" | \"repeat\" | \"modifiers\"\n\n# A list of modifiers that need to accompany the action for the command to happen\n- modifiers: Modifier[]\n\n# Name of the keycode that the action should respond to.\n# See https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h\n# for the list of available keycodes (e.g. KEY_ENTER, KEY_Z, etc.)\n- key: KeyCodeName\n</code></pre> <p>A <code>Modifier</code> is defined as one of the following names:</p> Name Description <code>primary</code> the key defined by the Action Key <code>alt</code> Any alt key <code>alt_left</code> The left alt key only <code>alt_right</code> The right alt key only <code>shift</code> Any shift key <code>shift_left</code> The left shift key only <code>shift_right</code> The right shift key only <code>ctrl</code> Any ctrl key <code>ctrl_left</code> The left ctrl key only <code>ctrl_right</code> The right ctrl key only <code>meta</code> The <code>super</code> or <code>windows</code> key <code>meta_left</code> The left <code>super</code> or <code>windows</code> key only <code>meta_right</code> The right <code>super</code> or <code>windows</code> key only <code>sym</code> The sym key <code>function</code> The <code>fn</code> key <code>caps_lock</code> The caps lock key <code>num_lock</code> The num lock key <code>scroll_lock</code> The scroll lock key"},{"location":"configuration/custom_actions/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\ncustom_actions:           # Set meta + D to open wofi\n  - command: wofi --show=drun\n    action: down\n    modifiers:\n      - primary\n    key: KEY_D\n</code></pre>"},{"location":"configuration/default_keybinds/","title":"Default Keybinds","text":"<p>The compositors comes ships with a number of built-in commands. By default, these commands are bound to preset keybinds, but the user may change them to whatever they want. These commands may be overridden more than once and will respond to multiple key combinations as a result. Defining at least one override disables the default action.</p> <p>The default commands defined in the compositor are described in this table:</p> Name Description Keybind <code>terminal</code> Opens a new terminal <code>\u2756 Super + Enter</code> <code>request_vertical</code> Requests that the current window layout future windows vertially <code>\u2756 Super + v</code> <code>request_horizontal</code> Requests that the current window layout future windows horizontaly <code>\u2756 Super + h</code> <code>select_up</code> Select the window above currently selected window <code>\u2756 Super + \u2191</code> <code>select_down</code> Select the window above currently selected window <code>\u2756 Super + \u2193</code> <code>select_left</code> Select the window above currently selected window <code>\u2756 Super + \u2190</code> <code>select_right</code> Select the window above currently selected window <code>\u2756 Super + \u2192</code> <code>move_up</code> Move the currently selected window upwards <code>\u2756 Super + \u21e7 Shift + \u2191</code> <code>move_down</code> Move the currently selected window downwards <code>\u2756 Super + \u21e7 Shift + \u2193</code> <code>move_left</code> Move the currently selected window to the left <code>\u2756 Super + \u21e7 Shift + \u2190</code> <code>move_right</code> Move the currently selected window to the right <code>\u2756 Super + \u21e7 Shift + \u2192</code> <code>toggle_resize</code> Toggle resize mode on the active window <code>\u2756 Super + r</code> <code>resize_up</code> When resize mode is toggled on, this will decrease the size of the window vertically <code>\u2756 Super + \u2191</code> (only in resize mode) <code>resize_down</code> When resize mode is toggled on, this will increase the size of the window vertically <code>\u2756 Super + \u2193</code> (only in resize mode) <code>resize_left</code> When resize mode is toggled on, this will decrease the size of the window horizontally <code>\u2756 Super + \u2190</code> (only in resize mode) <code>resize_down</code> When resize mode is toggled on, this will increase the size of the window horizontally <code>\u2756 Super + \u2192</code> (only in resize mode) <code>fullscreen</code> Fullscreen the currently selected window <code>\u2756 Super + f</code> <code>quit_active_window</code> Close the currently selected window <code>\u2756 Super + \u21e7 Shift + Q</code> <code>quit_compostior</code> Exit the compositor <code>\u2756 Super + \u21e7 Shift + E</code> <code>select_workspace_[0-9]</code> Select the workspace between 0-9 <code>\u2756 Super + [0-9]</code> <code>select_workspace_[0-9]</code> Move the currently selected window to the workspace between 0-9 <code>\u2756 Super + \u21e7 Shift + [0-9]</code> <code>toggle_floating</code> Toggle whether or not the currently selected window is floating <code>\u2756 Super + Space</code> <code>toggle_pinned_to_workspace</code> Toggle whether a floating window is pinned outside of a workspace or not <code>\u2756 Super + \u21e7 Shift + P</code>"},{"location":"configuration/default_keybinds/#key","title":"Key","text":"<pre><code>default_action_overrides\n</code></pre>"},{"location":"configuration/default_keybinds/#value","title":"Value","text":"<p>A list of: </p> <pre><code># The name of the action that you want to override (taken from the list above)\n- name: string\n\n# The key action that will trigger the default action\n - action: \"up\" | \"down\" | \"repeat\" | \"modifiers\"\n\n# A list of modifiers that need to accompany the action for the command to happen\n- modifiers: Modifier[]\n\n# Name of the keycode that the action should respond to.\n# See https://github.com/torvalds/linux/blob/master/include/uapi/linux/input-event-codes.h\n# for the list of available keycodes (e.g. KEY_ENTER, KEY_Z, etc.)\n- key: KeyCodeName\n</code></pre> <p>A <code>Modifier</code> is defined as one of the following names:</p> Name Description <code>primary</code> the key defined by the Action Key <code>alt</code> Any alt key <code>alt_left</code> The left alt key only <code>alt_right</code> The right alt key only <code>shift</code> Any shift key <code>shift_left</code> The left shift key only <code>shift_right</code> The right shift key only <code>ctrl</code> Any ctrl key <code>ctrl_left</code> The left ctrl key only <code>ctrl_right</code> The right ctrl key only <code>meta</code> The <code>super</code> or <code>windows</code> key <code>meta_left</code> The left <code>super</code> or <code>windows</code> key only <code>meta_right</code> The right <code>super</code> or <code>windows</code> key only <code>sym</code> The sym key <code>function</code> The <code>fn</code> key <code>caps_lock</code> The caps lock key <code>num_lock</code> The num lock key <code>scroll_lock</code> The scroll lock key"},{"location":"configuration/default_keybinds/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\ndefault_action_overrides:\n  - name: terminal        # Override the \"terminal\" keybind to execute with \"Ctrl + Shift + Enter\"\n    action: down\n    modifiers:\n      - ctrl\n      - shift\n    key: KEY_ENTER\n</code></pre>"},{"location":"configuration/display_configuration/","title":"Display Configuration","text":"<p>Please note that the display configuration **is distinct from the configuration defined in the configuration section. The two may indeed overlap with one another. There is a task in miracle-wm to fix this.</p> <p>The Mir project provides a mechanism for configuring the display in a reproducible way. To use this, you may provide the following commandline argument when running miracle:</p> <pre><code>--display-config=static=/path/to/a/display/file.yaml\n</code></pre> <p>Alternatively, you may define the <code>display-config</code> option in Mir's Built-in Configuration, e.g.:</p> <pre><code># ~/.config/miracle-wm.config\n\ndisplay-config=static=/path/to/a/display/file.yaml\n</code></pre>"},{"location":"configuration/enable_animations/","title":"Enable Animations","text":"<p>Globally enable or disable animations.</p>"},{"location":"configuration/enable_animations/#key","title":"Key","text":"<pre><code>enable_animations\n</code></pre>"},{"location":"configuration/enable_animations/#value","title":"Value","text":"<pre><code>boolean\n</code></pre>"},{"location":"configuration/enable_animations/#default","title":"Default","text":"<pre><code>true\n</code></pre>"},{"location":"configuration/enable_animations/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nenable_animations: false  # disable animations globally\n</code></pre>"},{"location":"configuration/environment_variables/","title":"Environment Variables","text":"<p>A list of environment variables that are set when the compositor starts.</p>"},{"location":"configuration/environment_variables/#key","title":"Key","text":"<pre><code>environment_variables\n</code></pre>"},{"location":"configuration/environment_variables/#value","title":"Value","text":"<p>A list of:</p> <pre><code>- key: string\n- value: any\n</code></pre>"},{"location":"configuration/environment_variables/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nenvironment_variables:\n  - key: mesa_glthread  # Setting mesa_glthread to false fixes some AMD issues\n    value: false\n</code></pre>"},{"location":"configuration/inner_gaps/","title":"Inner Gaps","text":"<p>Gaps between windows in pixels.</p>"},{"location":"configuration/inner_gaps/#key","title":"Key","text":"<pre><code>inner_gaps\n</code></pre>"},{"location":"configuration/inner_gaps/#value","title":"Value","text":"<p>A 2D integer point describing the gaps in pixels in the X and Y directions: <pre><code>x: int\ny: int\n</code></pre></p>"},{"location":"configuration/inner_gaps/#default","title":"Default","text":"<pre><code>x: 10\ny: 10\n</code></pre>"},{"location":"configuration/inner_gaps/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\ninner_gaps:\n    x: 50 # 50px between windows horizontally\n    y: 20 # 20px between windows vertically\n</code></pre>"},{"location":"configuration/introduction/","title":"Introduction","text":"<p>Miracle is configured via a <code>YAML</code> file. This section describes the settings that you may define in that file.</p>"},{"location":"configuration/introduction/#file-location","title":"File location","text":"<p>The configuration file will be written blank the first time that you start the compositor. The file is located at <code>$XDG_CONFIG_HOME/miracle-wm.yaml</code>. It is written on the initial startup of <code>miracle</code> if it does not yet exist. The most likely location is:</p> <pre><code>~/.config/miracle-wm.yaml.\n</code></pre> <p>Note</p> <p>See the arch user guide for information about <code>$XDG_CONFIG_HOME</code>.</p>"},{"location":"configuration/mir/","title":"Mir's Built-in Configuration","text":"<p>Please note that Mir's built-in configuration **is distinct from the configuration defined in the configuration section. The two may indeed overlap with one another. There is a task in miracle-wm to fix this.</p> <p>Mir provides a built-in configuration on top of the one that miracle-wm defines.</p>"},{"location":"configuration/mir/#location","title":"Location","text":"<p>This file can be found at:</p> <pre><code>.config/miracle-wm.config\n</code></pre> <p>or at <code>$XDG_CONFIG_HOME/miracle-wm.config</code> if <code>$XDG_CONFIG_HOME</code> is defined.</p>"},{"location":"configuration/mir/#format","title":"Format","text":"<p>This configuration is in a typical key-value pair format, i.e.:</p> <pre><code>key=value\n</code></pre> <p>The list of valid <code>key</code>s can be found by running:</p> <pre><code>miracle-wm --help\n</code></pre> <p>The keys are the names of the commandline arguments</p>"},{"location":"configuration/mir/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.config\n\nx11-window-title=miracle-wm\nidle-timeout=600\ndisplay-config=sidebyside\nadd-wayland-extensions=zwp_idle_inhibit_manager_v1:zwp_input_method_v1\n</code></pre>"},{"location":"configuration/outer_gaps/","title":"Outer Gaps","text":"<p>Gaps between the window tiles and the edge of the screen.</p>"},{"location":"configuration/outer_gaps/#key","title":"Key","text":"<pre><code>outer_gaps\n</code></pre>"},{"location":"configuration/outer_gaps/#value","title":"Value","text":"<p>A 2D integer point describing the gaps in pixels in the X and Y directions: <pre><code>x: int\ny: int\n</code></pre></p>"},{"location":"configuration/outer_gaps/#default","title":"Default","text":"<pre><code>x: 10\ny: 10\n</code></pre>"},{"location":"configuration/outer_gaps/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nouter_gaps:\n    x: 50  # 50px between the tiling grid and the edge of the output, horizontally\n    y: 100 # 100px between the tiling grid and the edge of the output, vertically \n</code></pre>"},{"location":"configuration/resize_jump/","title":"Resize Jump","text":"<p>Defines the number of pixels that a window will be resized by for each resize request. This value affects any direction (up, down, left, or right).</p>"},{"location":"configuration/resize_jump/#key","title":"Key","text":"<pre><code>resize_jump\n</code></pre>"},{"location":"configuration/resize_jump/#value","title":"Value","text":"<p>An integer describing the number of pixels</p>"},{"location":"configuration/resize_jump/#default","title":"Default","text":"<pre><code>50\n</code></pre>"},{"location":"configuration/resize_jump/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nresize_jump: 25 # Each resize will now add or remove 25px from the current window size\n</code></pre>"},{"location":"configuration/startup_apps/","title":"Startup Apps","text":"<p>A list of applications that will be started when the compositor starts.</p>"},{"location":"configuration/startup_apps/#key","title":"Key","text":"<pre><code>startup_apps\n</code></pre>"},{"location":"configuration/startup_apps/#value","title":"Value","text":"<p>A list of:</p> <pre><code>- command: string  # A shell command to be executed\n\n# If true, the application will automatically restart\n- restart_on_death: bool\n</code></pre>"},{"location":"configuration/startup_apps/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\n# Start waybar and swaybg on startup\nstartup_apps:\n  - command: waybar\n    restart_on_death: true\n  - command: swaybg -i /path/to/my/image\n    restart_on_death: true\n</code></pre>"},{"location":"configuration/terminal/","title":"Terminal","text":"<p>Select which terminal will be opened by the <code>terminal</code> keybind (See Default Keybinds).</p>"},{"location":"configuration/terminal/#key","title":"Key","text":"<pre><code>terminal\n</code></pre>"},{"location":"configuration/terminal/#value","title":"Value","text":"<p>A string defining the terminal shell command</p>"},{"location":"configuration/terminal/#default","title":"Default","text":"<pre><code>miracle-mw-sensible-terminal\n</code></pre>"},{"location":"configuration/terminal/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nterminal: konsole # Set konsole as the default terminal\n</code></pre>"},{"location":"configuration/workspaces/","title":"Workspaces","text":"<p>Customize the behavior of a particular workspace number.</p>"},{"location":"configuration/workspaces/#key","title":"Key","text":"<pre><code>workspaces\n</code></pre>"},{"location":"configuration/workspaces/#value","title":"Value","text":"<p>A list of:</p> <pre><code>number: int  # Unique que of the workspace [0-9]\nlayout: tiled, floating  # Default layout style for this workspace\n</code></pre>"},{"location":"configuration/workspaces/#default","title":"Default","text":"<pre><code>workspaces:\n    - number: 0\n      layout: tiled\n    - number: 1\n      layout: tiled\n    - number: 2\n      layout: tiled\n    - number: 3\n      layout: tiled\n    - number: 4\n      layout: tiled\n    - number: 5\n      layout: tiled\n    - number: 6\n      layout: tiled\n    - number: 7\n      layout: tiled\n    - number: 8\n      layout: tiled\n    - number: 9\n      layout: tiled\n</code></pre>"},{"location":"configuration/workspaces/#example","title":"Example","text":"<pre><code># ~/.config/miracle-wm.yaml\n\nworkspaces:\n    - number: 1\n      layout: floating  # Override the default layout style to floating\n</code></pre>"},{"location":"getting_started/building/","title":"Building","text":""},{"location":"getting_started/building/#dependencies","title":"Dependencies","text":"<ul> <li>cmake &gt;= 3.7</li> <li>gcc or clang with C++23 support</li> <li>miral &gt;= 7</li> <li>mir-graphics-drivers-desktop &gt;= 2.14</li> <li>mir-graphics-drivers-nvidia &gt;= 2.14 (NVIDIA Only)</li> <li>glib-2.0</li> <li>yaml-cpp</li> <li>libevdev</li> <li>nlohmann json &gt;= 3.2.0</li> <li>libnotify</li> <li>libxkbcommon-devel</li> </ul>"},{"location":"getting_started/building/#from-source","title":"From source","text":"<pre><code>git clone https://github.com/mattkae/miracle-wm.git\ncd miracle-wm\n\ncmake -Bbuild\ncmake --build build\nWAYLAND_DISPLAY=wayland-98 ./build/bin/miracle-wm\n</code></pre>"},{"location":"getting_started/building/#snap","title":"Snap","text":"<pre><code>cd miracle-wm\nsnapcraft\nsudo snap install --dangerous --classic miracle-wm_*.snap\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#install","title":"Install","text":"SnapFedoraUbuntu (mantic and noble)Nightly <pre><code>sudo snap install miracle-wm --classic\n</code></pre> <pre><code>sudo dnf install miracle-wm\n</code></pre> <pre><code>sudo add-apt-repository ppa:matthew-kosarek/miracle-wm\nsudo apt update\nsudo apt install miracle-wm\n</code></pre> <pre><code>sudo snap install miracle-wm --classic --edge\n</code></pre>"},{"location":"getting_started/installation/#running","title":"Running","text":""},{"location":"getting_started/installation/#on-login","title":"On login","text":"<p>Once installed, you may select the \"Miracle\" option from your display manager before you login (e.g. <code>gdm</code> or <code>lightdm</code>). In most environments, this presents itself as a little \"settings\" button after you select your name.</p> <p>Note that if you installed the snap, the option may read \"Miracle (snap)\" to distinguish it from the binary version.</p>"},{"location":"getting_started/installation/#hosted","title":"Hosted","text":"<p>To run the window manager as a window on your current desktop session, simply run:</p> <pre><code>WAYLAND_DISPLAY=wayland-98 miracle-wm\n</code></pre> <p>Note that this is only useful if you want to test-drive the window manager or do some development on it for yourself.</p>"},{"location":"getting_started/what_is_a_wayland_compositor/","title":"What is a Wayland compositor?","text":"<p>This document is intended for users who are unfamiliar with compositors, Wayland, or Linux in general. It serves as a high-level introduction to the ecosystem in which this project exists.</p> <p>To understand <code>miracle-wm</code>, we will need to develop our understanding of the Linux graphics stack. In doing so, we'll explore everything from the application layer to the kernel so that we can understand the flow of visual graphics to your computer monitor.</p>"},{"location":"getting_started/what_is_a_wayland_compositor/#key-takeways","title":"Key Takeways \ud83d\udd11","text":"<ul> <li>Applications are written with the help pf GUI Toolkits, which abstract away common problems (e.g. text rendering, widgets, scale, keyboard &amp; mouse input, etc)</li> <li>Applications talk to a window manager using the Wayland protocol<ul> <li>GUI toolkits implement the client side of this protocol</li> </ul> </li> <li>Wayland protocols are specified in XML files and do not necessarily have support across different systems</li> <li>Wayland is the succesor to the X11 protocol</li> <li>Window managers implement the Wayland protocol</li> <li>Window managers rely on DRM/KMS, GBM, and EGLStreams (only Nvidia) for graphics buffer and display management</li> <li>Window managers rely on libinput for processing input and routing it to the proper windows</li> <li>Mir is the C++ library for writing Wayland compositors that <code>miracle-wm</code> uses</li> </ul>"},{"location":"getting_started/what_is_a_wayland_compositor/#how-do-desktop-applications-work-on-linux","title":"How do desktop applications work on Linux?","text":"<p>Imagine that we would like to build a \"Todo list\" desktop application for computers that are running the Linux operating system. We might want to build our application with the following features:</p> <ul> <li>A window on the user's desktop</li> <li>A button in this window to add a new item</li> <li>A modal that popus up when you click the \"new item\" button<ul> <li>This modal might contain a text input for entering the description of the todo item</li> </ul> </li> <li>A list of added todo items, with each item containing:<ul> <li>Text describing the item</li> <li>A checkbox describing the \"done\" state of the item</li> <li>A button to delete the item</li> </ul> </li> <li>And so on...</li> </ul> <p>While this application seems simple, we quickly see that there a number of complicated UI widgets and interactions here (e.g. buttons, modals, dynamic lists, text, etc.). On top of that, we might want to have our application translated into a number of different languges, which means that we'll have to render proper fonts for all different types of languages (including left-to-right and right-to-left written languages). Managing all of this is a very difficult problem, especially when you just want to build your todo app.</p> <p>This is where GUI tookits come into play. These toolkits handle the problems of rendering, widgets, animations, localization, mouse input, keyboard input, and much more. When we build our app on top of a toolkit, these common functionalities are given to us for free.</p> <p>Note</p> <p>Some of the toolkits on Linux that you may be familiar with are GTK, QT, Flutter, and Electron. There are many other toolkits, as well, but these ones are particularly popular.</p>"},{"location":"getting_started/what_is_a_wayland_compositor/#how-do-gui-toolkits-work","title":"How do GUI toolkits work?","text":"<p>If you look around the screen that you're reading this webpage on, you probably see a number of other applications in addition to your web browser. You might see a top panel displaying the date and time. You might see a dock displaying icons of the applications that you can open. You might see your favorite text editor like Visual Studio Code open. You might even see a todo app! Each of these application wants to render to the screen, receive mouse and keyboard input, and more. </p> <p>Linux orchestrates visual applications with the help of a window manager (a.k.a a display server or compositor). This is a single process that starts as soon as you log into your user account. Each application on your desktop tells the window manager that it wants to render something to the screen. The window manager is then responsible for combining the images submitted by each application into one final image that is sent off to your screen.</p> <p>The communication protocol used between applications and the window manager is called Wayland. You may think of Wayland in the same way that you think of HTTP. Clients (applications) ask the Server (window manager) to perform some action (e.g. show something on the screen, become fullscreen, etc.). The window manager then has the authority to either accept or deny that request.</p> <p>Among the responsibilities of the window manager are:</p> <ul> <li>Placing each application in an appropriate position on the screen(s)</li> <li>Stitching together the images displayed by each application and sending the final image off to the screen(s)</li> <li>Routing keyboard, mouse, stylus and any other inputs to the proper application (e.g. the currently focused application)</li> <li>Maximizing and minimizing applications</li> <li>Dragging applications around on the screen</li> <li>Switching workspaces</li> <li>Alt-tabbing</li> <li>Exposing onscreen keyboards</li> <li>Handling session locking</li> <li>And much, much more</li> </ul> <p>Note</p> <p>You are probably most familiar with \"floating\" window managers. These window managers are typical of a baseline \"Windows 10\" user experience. However, this is not the only way to manage your windows! For example, <code>miracle-wm</code> is a tiling window manager, meaning that it treats windows as individual tiles instead of surfaces that are floating in a pool.</p> <p>GUI toolkits abstract the Wayland protocol away from application developers so that they don't have to worry about the details of Waylalnd. Given that the protocol itself is quite complicated, it is a good thing that they do this. You as an application developer can choose to not use a GUI toolkit and implement the client-side of the Wayland protocol yourself, but this would be incredibly time-consuming. On top of that, you would have to implement all of these previously mentioned aspecs of a GUI toolkit (e.g. widgets, input, animations, text rendering etc.). Needless to say, unless you plan to make it your full-time job (or you're a dedicated hobbyist!) it probably isn't worth your time.</p>"},{"location":"getting_started/what_is_a_wayland_compositor/#how-does-wayland-work","title":"How does wayland work?","text":"<p>The Wayland protocol is specified via XML files. While there exists only a single necessary Wayland protocol (known as wayland.xml), window managers are free to implement as many optional protocol extensions as they see fit for their use case. Each protocol provides some new functionality like screencopy, on-screen keyboard support, viewporter for surface cropping and scaling, and many more. The list of possible protocols is theoretically as infinite, as window manager developers are free to implement any that they deem appropriate. As an example, KDE defines a number of protocols that are specific to their desktop environment.</p> <p>While window managers can theoretically support any protocols that they like, a protocol will only see use if there are clients for that protocol. As a result, there is a somewhat \"official\" list of protocols that are maintained by freedesktop.org, which you can find at https://gitlab.freedesktop.org/wayland/wayland-protocols. To get a protocol accepted into this repository, there needs to be widespread consensus among popular Wayland compositors that the protocol is the right solution. Once the protocol gets accepted, each compositor must implement the protocol themselves.</p> <p>If you'd like to get an overview of Wayland protocols that have been implemented in some system, check out https://wayland.app/protocols/.</p> <p>Warning</p> <p>Wayland protocols are loosely defined. This means that different compositors may implement the same protocol in different ways. Oftentimes, the behavior converges to \"whatever GNOME does\" or \"whatever KDE does\" instead of something well-defined in the specification. On top of that, the protocols often fail to define how their protocol should interact with another protocol, which leaves compositor-implementers to fill in the blanks on their own. This is just a warning in case you encounter slightly different behaviors in different environments.</p>"},{"location":"getting_started/what_is_a_wayland_compositor/#the-history-of-wayland","title":"The history of Wayland","text":"<p>Unfortunately, it doesn't feel right to tell you about Wayland if I don't also provide a quick aside to inform you about its predecessor: X11. I won't get into the nitty-gritty details here (especially since I was never an X11 developer) but I will explain enough to clear up some confusion. </p> <p>For most of its history, Linux applications used the X11 (or simply X) protocol to handle window management. The X ecosystem is much different compared to the Wayland, and I'm afraid it has led to a bit of confusion among people trying to understand Linux GUI applications for the first time. For starters, there existed only one true implementation of an X11 server on Linux. This was known as the X.Org Server. All Linux distributions ran a similar X.Org server underneath the hood. This was known as the \"compositor\" because it was responsible for \"compositing\" the final image and sending it off to the displays. The \"compositor\" was only responsible for compositing however. A separate process usually existed to facilitate the window management aspects of the compositors, which was fittingly called the window manager. By \"window management aspects\", I am refering to features such as:</p> <ul> <li>Placing new windows</li> <li>Allowing windows to be dragged around (or not)</li> <li>Moving windows based off keyboard input</li> <li>Fullscreening windows</li> <li>etc.</li> </ul> <p>Hence, if you ever installed the i3 window manager (as an example), you were installing a window manager while the X.Org server remained your compositor. This is why you will see the terms \"window manager\" and \"compositor\" used interchangeably when descibing a Wayland window manager. In the Wayland world, these are no longer two distinct processes like there were in the X days.</p> <p>Fast forward to some time in the early 2010s, the X.Org developers finally had enough of X11. The entire ecosystem had a lot of cruft and a lot of hacks. On top of that, X11 failed terribly in terms of security. The X developers figured that it would be much easier to redesign a new protocol from the ground-up. That is when Wayland was born! Unlike X11 whose only real implementation was the X.Org server, Wayland was designed to just be a set of protocol definitions. This means that anyone can write their own Wayland server so long as they implement the protocols correctly.</p> <p>That is as deep as I will go into the history of Wayland. It is obviously much deeper than this and I wasn't around during that time so I can't speak to the specifics. If you ever want to seek out an ex-X11 developer at an XDC conference, I'm sure that they have many horror stories to tell you.</p> <p>Let's get back to the graphics stack now!</p>"},{"location":"getting_started/what_is_a_wayland_compositor/#how-do-window-managers-or-compositors-work","title":"How do window managers (or \"compositors\") work?","text":"<p>I will now give a brief introduction into how \"window managers\" work. However, the details of such a complex piece of software would take a novel to describe accurately, so it should suffice to provide a high-level overview of what a window manager does.</p> <p>Most importantly, window managers (or \"compositors\") implement the server side of the Wayland protocol. The window manager can choose to implement any number of Wayland protocols that it likes, but it must at the very least implement the \"core\" Wayland protocol. Clients connect to the Wayland server via a wayland socket (which you may be able to read by running <code>echo $WAYLAND_DISPLAY</code> in you terminal).</p> <p>This window manager process is most likely started by your login manager via <code>systemd</code> when you log in, although you may start it manually from a TTY by yoursef. This process has special access to the hardware resources of your system through the <code>DRM/KMS</code> subsystem that the kernel exposes. This subsystem exposes an API that allows the window manager to accomplish some of its primary tasks, such as:</p> <ul> <li>Setting the output dimensions and refresh rates of your monitors</li> <li>Managing graphics buffers</li> </ul> <p>Graphics buffers are typically allocated with the help of the Generic Buffer Management (GBM) API. This API is part of Mesa's interface. Mesa is an open-source implementation of OpenGL. At the time of writing this document, Nvidia provides an EGLStreams API for allocating buffers on its GPUs in place of the GBM API. The job of the window manager is to accept the buffers submitted by its various clients, render them all into a buffer per-output, and submit each buffer to the corresponding output.</p> <p>On top of managing the display, the window manager is also responsible for processing input and routing it to the correct clients. The window manager does this with the help of libinput which is another project run by freedesktop.org. This API monitors input events from the kernel (e.g. mouse clicks, keyboard input, stylus input, etc.) and sends the events off to the window manager so that it can do something with them. Most likely the window manager will route these events to a client, but the window manager may also use this input to execute some custom behavior, like a global keyboard shortcut.</p> <p>While the window managers core responsibility is to show buffers on screen and manage input, it also can potentially do a lot more things, many of which are tangentially related to its core responsibility. This might include clipboard management, screen casting, global keybinds, and much more. All of this is up to the window manager developer.</p> <p>With all of this being said, you might think that developing a Wayland window manager from scratch is a daunting task. And you would be correct to think this! Luckily, other people have thought the same thing, which is why some projects have arisen to handle the commonalities of window manager development for you. Two prominent examples of such libraries are:</p> <ul> <li>Mir: a C++ library for writing Wayland compositors that is maintained by Canonical</li> <li>wlroots: a C library for writing Wayland compositors</li> </ul>"}]}